= Route Resolution Scenarios

== Any-to-Any Table Model

=== Assumptions

* Partner represents the company itself, for example name and identifiers and contacts, without any partnership
* Every Partner has a namespace it can use for any partners it talks to. (A:*)
* Every partner to partner relationship has/is a namespace for artifacts used only between them
* All artifacts live in or belong to a partnership/namespace.
* Every partner has visibility into (a relationship with?) the  *:* “shared” partner
* Route resolution does not care about inbound vs. outbound, it’s always the same algorithm.
* All Routes have a From Partner attribute - to prevent self-subscribing
** From Partner can be null (*)
* All Routes also have a To Partner attribute - to enable filtering and tracking.
** To Partner can’t be null

=== Definitions/notation

FP::
From Partner

TP::
To Partner

USC::
Unique Search Criteria (Usually: Std, Ver, MsgType, etc., From, and To)

Multicast:: 
TP is not provided

*:: ANY Partner

XP:YP::
Partnership between Partner X and Partner Y

XP:*::
Partnership between Partner X and all other partners

=== Rules

* All Multicast documents must be defined in the Multicasting Partnership (MP:*) or Shared Space (*:*).
* Routes Definitions have From (Can be *) and To (Cannot be *) Partners
* Route Resolution Queries must have From Partner
* It is now ok to have multiple source channels for a single doc type
* (Soft) Routes must be in a Partnership between partners (FP:TP)
* (Soft) When you add a route definition, if USC already exists but for a diff doc def.
** Warn the User


=== Routing Table

|===

|From |To |Standard |Version |MsgType |Doc ID|Partnership |Source Channel |Route ID

|Value
|Value
|Value
|Value
|Value
|Value
|Value
|Value
|Value

|===


|===

|From |To |URN |Route ID

|Value
|Value
|Value
|Value
|Value
|Value
|Value
|Value
|Value

|===


This table is either:

* Compiled by addition as new Route Definitions are created, or
* A view created by joining doc def, source channel, and route tables.
* From can be * or ANY
* Should be Unique on Route ID column
* USC = From, To, URN (Standard, Version, MsgType, etc.)

=== Resolution Logic
. Find FP and TP id’s using the identifiers.
.. If FP is null, throw error.
. Search Routing Table
.. Using USC filter Route Table and find all rows that match the USC.
... If From is * in the table, accept all Documents where the missing From partner has a partnership with the To partner.
.. Gather all Routes that match.
... Inspect all Source Document Definitions from all the Routes.
.... If they are all the same Definition then Continue.
.... If they are not all the same throw warning and continue.
. (Future) Filter Source Channels found using Content-based Route Filter . (CBRF)
. Filter Routes found in 2 using CBRF
. Return results


== Scenarios

=== Shared 

* Everything in Partnership A:*
* Three partners: A,B and C
* Partner A wants to receive Document Q from Partner C but not from Partner B

==== Artifact Location

|===
|Source 4+|Source| 4+|Target

|Owner 
|Doc Def In
|Channel
|Map
|Canonical 
|Route
|Channel
|Map
|Doc Def Out
|Endpoint

|A:*
|✓
|✓
|✓
|✓
|
|✓
|
|✓
|✓

|A:B
| 
| 
| 
| 
| 
| 
| 
| 
| 


|A:C
| 
| 
| 
| 
|✓
| 
| 
| 
| 
| 

|===

==== Routing Table

|===

|From |To |Standard |Version |MsgType |Doc ID|Partnership |Source Channel |Route ID

|C
|A
|CSV
|1
|Q
|123
|A:C
|xyz
|1

|===


=== Override

C sends doc to A with From = C and To = A
Routing Engine finds Route ID 1
Successfully delivers message
B sends doc to A with From = B and To = A
Routing Engine finds nothing and Stops.

Scenario #2: Default in Partnership A:*, B does something different.
4 partners A,B,C,D
Partner A wants to receive Document Q from Partner D,C
Partner A wants to receive Document Q’ from Partner B
Q and Q’ both have same Std, Ver, MsgType, etc.
Canonical lives in *:*

Artifact Location



Source


Target
Owner
Doc
Def In
Channel
Map
Canonical 
Route
Channel
Map
Doc
Def
Out
Endpoint
A:*
Q
SCQ
✓




TC


✓
✓
A:B








SCQ’✓TC








A:C








SCQ✓TC








A:D








SCQ✓TC








B:*
Q’
SCQ’
✓












*:*






✓











Routing Table

From
To
Standard
Version
MsgType
Doc ID
Route Partnership
Source Channel
Route ID
C
A
CSV
1
Que
123
A:C
SCQ
1
D
A
CSV
1
Que
123
A:D
SCQ
2
B
A
CSV
1
Que
234
A:B
SCQ’
3


Flow: 
C sends doc to A with From = C and To = A
Routing Engine finds Route ID 1
D sends doc to A with From = D and To = A
Routing Engine finds Route ID 2
B sends doc to A with From = B and To = A
Routing Engine finds Route ID 3

Scenario #2.5 (Bad): Default in Partnership A:*, B does something different. A:* tries to have a default transaction.
4 partners A,B,C,D
Partner A wants to receive Document Q from anyone they are Partners with
Partner A wants to receive Document Q’ from Partner B
Q and Q’ both have same Std, Ver, MsgType
Canonical lives in *:*

Artifact Location



Source


Target
Owner
Doc
Def In
Channel
Map
Canonical 
Route
Channel
Map
Doc
Def
Out
Endpoint
A:*
Q
SCQ
✓


SCQ✓TC
TC


✓
✓
A:B








SCQ’✓TC








A:C


















A:D


















B:*
Q’
SCQ’
✓












*:*






✓











Routing Table

From
To
Standard
Version
MsgType
Doc ID
Partnership
Source Channel
Route ID
*
A
CSV
1
Que
123
A:*
SCQ
1
B
A
CSV
1
Que
234
A:B
SCQ’
2


Flow: 
C sends doc to A
Routing Engine finds Route ID 1
D sends doc to A
Routing Engine finds Route ID 1
B sends doc to A
Routing Engine finds Route ID 2 and Route ID 1
Routing engine executes both!

Solution:
Either:
Stop the user from making Routes in A:* and force them to always makes routes in the Partnerships between Partners. (See soft rule above)
Alert the user of the overlap and ask them to add in a CBRF on the Source Channel.

Scenario #3: Partner wants to both Pass-Through and Map an incoming document.
2 partners A,B
Partner A wants to receive Document Q from Partner B
Partner A wants to PassThrough Q to 1 system.
Partner A wants to Map Q through Canonical as well.

Artifact Location
SCQM = Source Chanel for Q with Map
SCQPT = Source Chanel for Q with Passthrough



Source


Target
Owner
Doc
Def In
Channel
Map
Canonical 
Route
Channel
Map
Doc
Def
Out
Endpoint
A:*
Q
SCQM
SCQPT
✓
N/A




TCM
TCPT
✓
N/A
✓
✓
✓
✓
A:B








SCQM✓TCM
SCQPT✓TCPT








*:*






✓











Routing Table

From
To
Standard
Version
MsgType
Doc ID
Partnership
Source Channel
Route ID
B
A
CSV
1
Que
123
A:B
SCQM
1
B
A
CSV
1
Que
123
A:B
SCQPT
2


Flow: 
B sends doc Q to A
Routing Engine finds Route ID 1
Routing Engine finds Route ID 2
Routing Engine Executes both.
Scenario #4: Multicast
4 partners A,B,C,D
Partner A wants to multicast Document Q to everyone.
Partner B,D wants to map it to Canonical
Partner C wants it in the raw form.

Artifact Location
SCQMC = Source Chanel for Q with Map to Canonical
SCQ = Source Chanel for Q with no Map



Source


Target
Owner
Doc
Def In
Channel
Map
Canonical 
Route
Channel
Map
Doc
Def
Out
Endpoint
A:*
Q
SCQMC
✓












A:B








SCQM✓TCB
TCB


✓
✓
A:D








SCQM✓TCD
TCD


✓
✓
A:C


SCQ




SCQ✓TCC
TCC


✓
✓
*:*






✓











Routing Table

From
To
Standard
Version
MsgType
Doc ID
Partnership
Source Channel
Route ID
A
C
CSV
1
Que
123
A:B
SCQM
1
A
B
CSV
1
Que
123
A:C
SCQ
2
A
D
CSV
1
Que
123
A:D
SCQM
3


Flow: 
A sends Q with From Parter = A and To Partner = *
Routing Engine finds Route ID 1
Routing Engine finds Route ID 2
Routing Engine finds Route ID 3
Routing Engine Executes all.

Scenario #5: Service Manager Logger
3 Apps A,B,C
1 Logger L
The Logger wants to collect all Logs from A,B,C.
A,B send specifically to L
C sends logs to everyone.

Artifact Location
SCQMC = Source Chanel for Q with Map to Canonical
SCQ = Source Chanel for Q with no Map



Source


Target
Owner
Doc
Def In
Channel
Map
Canonical 
Route
Channel
Map
Doc
Def
Out
Endpoint
L:*








SCLog✓TC
TC


✓
✓
A:B


















A:D


















A:C


















*:*
Log
SCLog















Routing Table

From
To
Standard
Version
MsgType
Doc ID
Partnership
Source Channel
Route ID
*
L
CSV
1
Log
123
L:*
SCLog
1


Flow: 
A sends Log From Parter = A and To Partner = L
Routing Engine finds and executes Route ID 1
C sends Log From Parter = C and To Partner = *
Routing Engine finds and executes Route ID 1
Scenario #6: Two Big Hitters
2 Main Partners A,B
They both have their own definition of Q.
Qa and Qb both have the same Std, Ver,MsgType.
B sends Qb to A
A sends Qa to B

Artifact Location





Source


Target
Owner
Doc
Def In
Channel
Map
Canonical 
Route
Channel
Map
Doc
Def
Out
Endpoint
A:*
Qa
SCQa
✓




TCa


✓
✓
B:*
Qb
SCQb
✓




TCb


✓
✓
A:B








SCQa✓TCb
SCQb✓TCa








*:*






✓











Routing Table

From
To
Standard
Version
MsgType
Doc ID
Partnership
Source Channel
Route ID
A
B
CSV
1
Que
123
A:B
SCQa
1
B
A
CSV
1
Que
432
A:B
SCQb
2


Flow: 
A sends Qa From Parter = A and To Partner = B
Routing Engine finds and executes Route ID 1
B sends Qb From Parter = B and To Partner = A
Routing Engine finds and executes Route ID 2



_________________________________ Future Ideas ________________________________
Scenario #7: Delayed Routing
This scenario uses the Delayed Routing in the Resolution Logic
3 Partners A,B,C
A is sending a document Q to B and C
We cannot extract the To Partner from Q before we map.

Artifact Location





Source


Target
Owner
Doc
Def In
Channel
Map
Canonical 
Route
Channel
Map
Doc
Def
Out
Endpoint
A:*
Q
SCQ
✓












A:B








SCQ✓TCb
TCb


✓
✓
A:C








SCQ✓TCc
TCc


✓
✓
*:*






✓











Routing Table

From
To
Standard
Version
MsgType
Doc ID
Partnership
Source Channel
Route ID
A
B
CSV
1
Que
123
A:B
SCQ
1
A
C
CSV
1
Que
123
A:C
SCQ
2


Flow: 
A sends Q  with From Parter = A and To Partner = *
Routing Engine finds and executes Source Channel SCQ and extracts data from the Map.
Routing engine then uses that data to do CBR on both Route 1 and 2.
Routing engine runs only the Route that matches.

Resolution Logic with *Delayed Routing*
Find FP and TP using the identifiers
If FP is null, throw error.
Search Routing Table
Using USC filter Route Table and find all rows that match the USC.
If From or To is * in the table, accept all Documents where the missing partner has a partnership with the other partner.
Gather all Routes that match.
Filter Source Channels found using Content-based Route Filter (CBRF)
Execute Source Channel Map
Filter Routes found using CBRF using Data extracted from Map
Return results
